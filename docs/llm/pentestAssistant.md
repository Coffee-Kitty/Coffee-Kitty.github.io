<!--
 * @Author: coffeecat
 * @Date: 2025-03-04 16:53:48
 * @LastEditors: Do not edit
 * @LastEditTime: 2025-03-05 17:57:28
-->
# PentestAssistant
PentestAssistant 基于 Web 渗透检测工具，构建常用函数调用 API 知识库，
通过多代理的方式实现渗透任务建立和维护，
基于 RAG 技术实现渗透检测任务的执行，以此完成渗透检测的自动化过程。
> 什么意思？？？

![alt text](assets/pentestAssistant/image-1.png)

支持两种渗透检测使用方式：
单一工具调用：指定渗透检测工具，用户给定自然语言描述任务，系统根据请求自动完成工具调用和执行
多工具联合调用：选择多款渗透检测工具，用户给定自然语言描述任务，系统自动选择工具，执行函数，实现需求



## 环境搭建与启动

```bash
#创建容器
sudo docker run -it --name penassit  -v ./xsc_workspace:
/workspace -p 8888:8888 pytorch/pytorch /bin/bash


apt upgrade
git clone https://github.com/HUSTInfSecLabs/PentestAssistant.git

# 请注意python版本 3.10比较好
# python --version
# Python 3.10.13

pip install -r requirements.txt 

#----------------------------------------------
# 安装插件和所需要的依赖包
pip3 install --upgrade setuptools
# CMSeek
git clone https://github.com/Tuhinshubhra/CMSeeK
pip install -r ./CMSeek/requirements.txt
mv ./CMSeeK/* ./plugin/CMSeek/
# Dirsearch
 git clone --branch v0.4.3 https://github.com/maurosoria/dirsearch.git
 pip install -r ./dirsearch/requirements.txt
 mv ./dirsearch/* ./plugin/Dirsearch/
# # Tplmap
#  git clone https://github.com/epinna/tplmap.git
#  pip install -r ./tplmap/requirements.txt --use-deprecated=legacy-resolver
#  mv ./tplmap/* ./plugin/Tplmap/Tplmap/
# XSStrike
 git clone https://github.com/s0md3v/XSStrike.git
 pip install -r ./XSStrike/requirements.txt
 mv ./XSStrike/* ./plugin/XSStrike/

```

```python
reranker_path = ./bge-reranker-large
[LLM]
llm_service = DeepSeek
llm_call_type = api

[LLM.DeepSeek]
model_name = DeepSeek-R1-Distill-Llama-70B
api_key = token123456
base_url = http://127.0.0.1:8888/v1
```

In this project, we use a reranker model to sort all api list to help LLM reduct the selection range, so we should download this reranker model: bge-reranker-large and modify the configuration.

```bash
curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh 
apt-get install git-lfs
git lfs install
GIT_LFS_SKIP_SMUDGE=1 git clone https://huggingface.co/BAAI/bge-reranker-large

cd bge-reranker-large

# 查看 LFS 文件指针（未下载时显示指针哈希）
git lfs ls-files

git lfs pull #全部文件
cd ..

```

Moreover, we need to install the following penetration testing tools for PenetestAssistant to call: Nmap, Sqlmap, **Tqlmap**, **Xsstrike**,  Dnsenum, Hydra, and **Dirsearch**. 

For Xsstrike, Tplmap, Dirsearch, and CMSeek, we have included them in our source code, so we do not need to install them again.




```bash
#安装sudo
# find /etc/sudoers.d
# 上述命令返回 No such file or directory，就说明你的系统没有安装sudo
apt-get install sudo
sudo apt update

#安装nmap
sudo apt install nmap
# sqlmap
sudo apt install sqlmap
sudo apt upgrade sqlmap
# dnsenum
sudo apt install dnsenum
#hydra
sudo apt install hydra

#验证
nmap --version 
sqlmap --version
hydra --version
dnsenum.pl --help

# Nmap version 7.80 ( https://nmap.org )
# 1.6.4#stable
# Hydra v9.2 (c) 2021

```


```bash
pip install --force-reinstall -v “openai==1.55.3”
```



```python
#启动
python app.py
```

成功启动如下:
![alt text](assets/pentestAssistant/image.png)

### conquer
最开始因为卡的原因，使用的1.5B的模型，结果模型理解能力太差了，
又发现rerank-model仅仅占用400MB左右的显存，
所以再次启动70B的ds，然后设置显存利用率为0.9（由此需要的平衡操作是限制model-seq-len参数），
然后有了较好结果：
![alt text](assets/pentestAssistant/image-2.png)


## 代码熟悉
### plugin

在该文件夹下是各个工具的使用方法
![alt text](assets/pentestAssistant/image-3.png)
以nmap为例子，
![alt text](assets/pentestAssistant/image-4.png)
```json
{"name": "default_scan", "description": "Perform a default port scan on a certain IP or URL to detect the services enabled by the target", "args": [{"name": "target", "description": "Target ip or hostname"}], "exec_str": "nmap -sV -sC '{{target}}'"}
```
可见，这是nmap的操作cmd命令指南

然后在plugin.py文件中对插件调用进行了封装。
```python
# plugin/plugin.py

#对一条命令的
#的参数的名称和功能描述的封装
class Parameter:
    name: str
    description: str

    def __init__(self, data: dict) -> None:
        self.name = data["name"]
        self.description = data["description"]

#对一条命令的封装
#包括 该命令名称、命令功能描述、参数列表、执行表达式
class Function:
    name: str
    description: str
    parameters: List[Parameter]
    exec_str: str

    def __init__(self, data: dict) -> None:
        self.name = data["name"]
        self.description = data["description"]
        self.exec_str = data["exec_str"]
        self.parameters = []
        for arg in data["args"]:
            self.parameters.append(Parameter(arg))
#对一组命令的封装
class Skill:
    functions: List[Function]

    def __init__(self, data: List[str]) -> None:
        self.functions = []
        for item in data:
            item = json.loads(item)
            self.functions.append(Function(item))

    def get_function(self, name: str) -> Function:
        for function in self.functions:
            if function.name == name:
                return function

        return None


# 比如说对上述例子中 nmap的jsonl文件的封装
class Plugin:

    def __init__(self) -> None:
        self.plugin_dir = os.path.dirname(__file__)
        # /PentestAssistant/plugin

    def read_skill(self, skill_name: str) -> Skill:
        skill_file_path = os.path.join(self.plugin_dir, skill_name ,f"{skill_name}.jsonl")
        # 即上述例子中的 nmap的jsonl文件

        if not os.path.exists(skill_file_path):
            return []

        with open(skill_file_path, "r") as fp:
            lines = fp.readlines()

        return Skill(lines)

```


### model
这里没什么可说的
就是首先实现一个抽象基类ChatModel，

```python
from abc import ABC, abstractmethod


class ChatModel(ABC):

    def __init__(self) -> None:
        super().__init__()

    @abstractmethod
    def chat(self, prompt: str = None) -> str:
        pass

```
然后之后所有的model通过继承该类，实现chat方法用于交互，  
值得一提的是，这里都用的openai的库实现，而且通过配置文件确定读取那个api   
如下面的deepseek
```python
from model.base import ChatModel
from config import config_manager

from openai import OpenAI


class GPTChatModel(ChatModel):

    def __init__(self):
        super().__init__()
        api_key = config_manager.config["LLM.GPT"]["api_key"]
        base_url = config_manager.config["LLM.GPT"]["base_url"]
        self.model_name = config_manager.config["LLM.GPT"]["model_name"]
        self.client = OpenAI(api_key=api_key, base_url=base_url)

    # 基本的模型对话
    def chat(self, prompt: str = None) -> str:
        completion = self.client.chat.completions.create(
            model=self.model_name,
            messages=[{
                'role': 'system',
                'content': 'You are a helpful assistant.'
            }, {
                'role': 'user',
                'content': prompt,
            }],
        )
        return completion.choices[0].message.content

```

> 这里qwen加了一个function calling，而其他的如deepseek并未实现
``` python
"""
tool的格式
以nmap工具为例子
skill_name即工具名称nmap，function即nmap的一条命令，args是该命令相关参数
tool = {
            "type": "function",
            "function": {
                "name": self.skill_name + "." + function.name,
                "description": function.description,
                "parameters": {
                    "type": "object",
                    "properties": {
                        arg.name: {
                            "type": "string",
                            "description": arg.description
                        }
                        for arg in function.parameters
                    }
                },
                "required": []
            }
        }
"""
# 模型调用工具！！！
# 模型根据可调用工具命令 选择最合适的命令及具体参数
def function_call(self, prompt: str = None, tools: Optional[List[Dict]] = None) -> str:
        completion = self.client.chat.completions.create(
            model=self.model_name,
            messages=[{
                'role': 'system',
                'content': 'You are a helpful assistant.'
            }, {
                'role': 'user',
                'content': prompt,
            }],
            tools=tools,
        )
        return completion.model_dump()['choices'][0]['message']['tool_calls'][0]['function']
"""
返回示例：
{
    "name": "nmap.scan_network",
    "arguments": "{\"target\": \"192.168.1.0/24\"}"
}
然后后续供shell解析执行即可
"""
```


### planner
首先是两个抽象基类
```python
# 对执行计划的封装
# 包括prompt,goal, 生成的计划
class Plan:
    """A simple plan object for the Semantic Kernel"""

    def __init__(self, prompt: str, goal: str, generated_plan: Union[dict, str]):
        self.prompt = prompt
        self.goal = goal
        self.generated_plan = generated_plan

    def __str__(self):
        return f"Prompt: {self.prompt}\nGoal: {self.goal}\nPlan: {self.generated_plan}"

    def __repr__(self):
        return str(self)

# 计划具体执行器 --> 将自然语言plan翻译成具体命令plan并执行
# 具体做法是从 上述插件命令数据集中 检索最相关cmd命令,构造具体执行命令的计划， 并通过subprocess进行cmd的执行
class Planner(ABC):
    """A planner aim to retrieve similar api from specific database according to user query"""

    def __init__(self, chat_model: ChatModel, skill_name: str = None, reranker: Retrieval = None) -> None:
        self.skill_name = skill_name
        self.chat_model = chat_model
        self.reranker = reranker

    @abstractmethod
    def create_plan(self, goal: str) -> Optional[Plan]:
        pass

    @abstractmethod
    def execute_plan(self, plan: Plan) -> str:
        pass
```

还是比如nmap_plammer
```python
class NmapPlanner(Planner):
    """A planner for nmap tool api retrieval"""

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)
        self.skill = plugin.read_skill(self.skill_name)


    # 根据工具命令的功能描述  与 目标goal 做相似度匹配， 获取topk的工具命令，
    # 这里是rag增强的，llm将基于topk命令进一步选择出最合适的命令及其参数
    def _create_available_functions(self, goal: str) -> str:
        """
        generates a filtered list of callable tools (functions) based on their relevance to a given goal.
        """
        functions = self.skill.functions
        functions_description = []
        for function in functions:
            functions_description.append(function.description)

        # 根据工具命令的功能描述  与 目标goal 做相似度匹配， 获取topk的工具命令
        topk_descriptions = self.reranker.compute_topk(goal, functions_description, top_k=10)

        # Create the [AVAILABLE FUNCTIONS] section of the tools
        tools = []
        for function in functions:
            if function.description not in topk_descriptions:
                continue

            tool = {
                "type": "function",
                "function": {
                    "name": self.skill_name + "." + function.name,
                    "description": function.description,
                    "parameters": {
                        "type": "object",
                        "properties": {
                            arg.name: {
                                "type": "string",
                                "description": arg.description
                            }
                            for arg in function.parameters
                        }
                    },
                    "required": []
                }
            }
            tools.append(tool)

        logger.info(": available_functions - {tools}".format(tools=tools))
        return tools


    def create_plan(
        self,
        goal: str,
    ) -> Tuple[int, Plan]:
        """
        Creates a plan for the given goal based off the functions that
        are available in the plugins.
        """

        # Create the tools list for the planner with the given goal
        tools = self._create_available_functions(goal)

        # llm将基于topk命令进一步选择出最合适的具体命令及其参数
        generated_plan = self.chat_model.function_call(goal, tools)
        logger.info(f"generated_plan - {generated_plan}")

        return 0, Plan(prompt=goal, goal=goal, generated_plan=generated_plan)

    # subprocess子进程
    # 调用具体nmap命令并获取结果
    def _exec_nmap(self, cmd: str) -> str:
        process = subprocess.run(cmd.split(), capture_output=True)

        if process.returncode != 0:
            logger.warn(f": nmap call error - {repr(cmd)} - {repr(process.stderr.decode())}")

        return process.stdout.decode("utf-8", "ignore")

    # llm生成的具体命令plan的执行
    # 调用上面函数执行命令并返回结果
    def execute_plan(self, plan: Plan) -> str:
        """
        Given a plan, execute each of the functions within the plan
        from start to finish and output the result.
        """
        logger.info(": Nmap Planner Plan -: {plan}".format(plan=repr(plan.generated_plan)))
        generated_plan_json = plan.generated_plan

        #这里就是llm生成的json解析
        # get function from generated_plan_json
        _, function_name = generated_plan_json["name"].split(".")
        function = self.skill.get_function(function_name)

        # parse params from generated_plan_json and exec function
        exec_str = function.exec_str
        if isinstance(generated_plan_json["arguments"], str):
            generated_plan_json["arguments"] = json.loads(generated_plan_json["arguments"])

        for arg_name, arg_value in generated_plan_json["arguments"].items():
            exec_str = exec_str.replace(f"{{{{{str(arg_name)}}}}}", str(arg_value))

        result = self._exec_nmap(exec_str)

        return result

```
>
>ToolsPlanner类与上述类差不多，
>NmapPlanner理论来讲应该是 通用的 。。。

此外，还有两个类ShortenSuggestion 和 CapChecker
```python
class CapChecker(Planner):

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)

    def create_plan(self, goal: str) -> Tuple[int, Plan]:
        logger.info(f": CapChecker input- {repr(goal)}")

        # Create the context for the planner
        prompt = PROMPT.format(input=goal)
        response = self.chat_model.chat(prompt)

        return 0, Plan(prompt=PROMPT, goal=goal, generated_plan=response)

    def execute_plan(self, plan: Plan) -> str:
        return int(plan.generated_plan)


class ShortenSuggestion(Planner):

    def __init__(self, chat_model, skill_name=None, reranker=None):
        super().__init__(chat_model, skill_name, reranker)

    def create_plan(self, goal: str) -> Plan | None:
        logger.info(f": Capability check query input - {repr(goal)}")

        # Create the context for the planner
        prompt = PROMPT.format(input=goal)
        response = self.chat_model.chat(prompt)

        return Plan(prompt=PROMPT, goal=goal, generated_plan=response)

    def execute_plan(self, plan: Plan) -> str:
        return plan.generated_plan

```

两个类的主要差别应该在于prompt，主要函数都是create_plan
对于CapChecker的prompt如下：
```python
"""
#这里是中文翻译，比较方便
-----------------------------------
你是一个精通Web渗透测试知识的规划机器人。
你的任务是根据你对渗透测试目标的理解，判断用户的[目标]是否需要使用NMAP工具、CMSeek工具、Dirsearch工具、Hydra工具、Sqlmap工具、Tplmap工具、XSStrike工具，还是仅仅需要分析总结。

- 如果以上工具都不需要，则输出“0”。
- 如果需要NMAP工具，则输出“1”。
- 如果需要CMSeek工具，则输出“2”。
- 如果需要Dirsearch工具，则输出“3”。
- 如果需要Hydra工具，则输出“4”。
- 如果需要Sqlmap工具，则输出“5”。
- 如果需要Tplmap工具，则输出“6”。
- 如果需要XSStrike工具，则输出“7”。
------------------------------------
"""
"""
You are a planning robot proficient in Web penetration testing knowledge.  
Your task is to determine, based on your understanding of penetration testing objectives, whether the user's [objective] requires the use of the NMAP tool, CMSeek tool, Dirsearch tool, Hydra tool, Sqlmap tool, Tplmap tool, XSStrike tool, or just analysis and summary.  

- If none of the above tools are required, output "0".  
- If the NMAP tool is required, output "1".  
- If the CMSeek tool is required, output "2".  
- If the Dirsearch tool is required, output "3".  
- If the Hydra tool is required, output "4".  
- If the Sqlmap tool is required, output "5".  
- If the Tplmap tool is required, output "6".  
- If the XSStrike tool is required, output "7".  

Do not output anything other than "0", "1", "2", "3", "4", "5", "6", "7". Stop output immediately after completing the task.  

Below are two examples:  

[Objective]  
Help me scan the ports of www.baidu.com and check for SQL vulnerabilities.  
[Output]  
5  

[Objective]  
Can you check if there are XSS vulnerabilities in the web service at 172.20.0.59:11453?  
[Output]  
7  

End of examples. Real application begins below:  

[Objective]  
{input}  
[Output]  
"""
```
简单来说，**对于目标goal，首先让llm判断下是否需要使用这些工具,这就是CapChecker的主要功能**
至于ShortenSuggestion的prompt如下：
```python
"""
你是一个句子压缩机器人，擅长将长建议缩短为简洁的建议，同时保留原意。要缩短的建议位于“[Advice]”部分下。请在“[Result]”部分下输出压缩结果。

以下是示例：

[Advice]
假设所有输入都是恶意的。使用“接受已知良好”的输入验证策略，该策略采用严格定义的可接受输入列表。拒绝任何不严格符合规范的输入或将其转换为合规形式。执行输入验证时，请考虑所有可能相关的属性，包括长度、输入类型、可接受值的全部范围、缺失或额外输入、语法、相关字段之间的一致性以及对业务规则的遵守情况。例如，作为业务规则，“boat”在语法上是有效的，因为它只包含字母数字字符。但是，如果输入预计只包含“红色”或“蓝色”等颜色，则无效。
不要仅仅依赖于识别恶意或格式错误的输入。这种方法很可能会漏掉至少一个不需要的输入，特别是如果代码环境发生变化，从而为攻击者绕过预期的验证留下了空间。但是，拒绝列表可以帮助检测潜在攻击或识别格式错误的输入，这些输入应该被直接拒绝。
构造 SQL 查询字符串时，使用严格的允许列表根据请求中参数的预期值来限制字符集。这间接减少了攻击面，但这种技术不如正确的输出编码和转义那么重要。
正确的输出编码、转义和引号是防止 SQL 注入的最有效解决方案，即使输入验证可以提供一些纵深防御。这是因为它有效地限制了可能出现在输出中的内容。输入验证并不总能防止 SQL 注入，特别是如果支持可能包含任意字符的自由文本字段。例如，名称“O'Reilly”可能会通过验证，因为它是英语中的常见姓氏。但是，它不能直接插入数据库，因为它包含撇号“'”，需要对其进行转义或以其他方式处理。在这种情况下，删除撇号可能会降低 SQL 注入的风险，但可能会因记录错误的名称而导致不正确的行为。
在可行的情况下，最安全的方法可能是完全禁止使用元字符，而不是对其进行转义。这提供了一定程度的纵深防御。将数据输入数据库后，后续处理步骤可能会在使用前忽略转义，并且您可能无法控制这些过程。

[结果]
输入验证策略：使用“接受已知良好”策略拒绝或转换不合规的输入，同时考虑长度、类型、范围、语法、一致性和业务规则。
避免仅依赖检测：不要仅依赖检测恶意或格式错误的输入；使用允许和拒绝列表增强安全性。
SQL 查询构造：使用允许列表来限制 SQL 查询字符集，但优先考虑输出编码、转义和引号，以有效防止 SQL 注入。
禁用元字符：在可行的情况下，完全禁用元字符而不是转义它们以提供更深层次的防御。

示例结束。实际应用从下面开始。使用“[End]”结束输出。

[建议]
{输入}
[结果]
"""


PROMPT = """
You are a sentence-compression robot skilled in shortening long advice into concise suggestions while preserving the original meaning. The advice to be shortened is under the "[Advice]" section. Please output the compressed result under the "[Result]" section.

Below is an example:

[Advice]  
Assume all inputs are malicious. Use an "accept known good" input validation strategy, which employs a strictly defined list of acceptable inputs. Reject any input that does not strictly conform to specifications or transform it into a compliant form. When performing input validation, consider all potentially relevant attributes, including length, input type, full range of acceptable values, missing or extra inputs, syntax, consistency between related fields, and compliance with business rules. For example, as a business rule, "boat" is syntactically valid because it contains only alphanumeric characters. However, it is invalid if the input is expected to include only colors such as "red" or "blue."  
Do not rely solely on identifying malicious or malformed inputs. This approach is likely to miss at least one unwanted input, especially if the environment of the code changes, leaving room for attackers to bypass expected validations. However, deny-lists can help detect potential attacks or identify inputs so malformed they should be outright rejected.  
When constructing SQL query strings, use a strict allow-list to limit the character set based on the expected values of parameters in the request. This indirectly reduces the attack surface, but this technique is less critical than proper output encoding and escaping.  
Proper output encoding, escaping, and quoting are the most effective solutions for preventing SQL injection, even though input validation may provide some defense-in-depth. This is because it effectively limits the content that may appear in the output. Input validation does not always prevent SQL injection, particularly if free-text fields that may contain arbitrary characters are supported. For example, the name "O'Reilly" might pass validation because it is a common surname in English. However, it cannot be directly inserted into a database because it contains the apostrophe character "'", which needs to be escaped or otherwise handled. In such cases, removing apostrophes might reduce the risk of SQL injection but could cause incorrect behavior by recording incorrect names.  
Where feasible, the safest approach may be to completely disallow the use of meta-characters rather than escaping them. This provides a level of defense-in-depth. Once data is input into the database, subsequent processing steps might ignore escaping before use, and you may not control those processes.  

[Result]  
Input validation strategy: Use an "accept known good" strategy to reject or transform non-compliant inputs while considering length, type, range, syntax, consistency, and business rules.  
Avoid sole reliance on detection: Don't rely solely on detecting malicious or malformed inputs; enhance security with allow- and deny-lists.  
SQL query construction: Use allow-lists to restrict SQL query character sets, but prioritize output encoding, escaping, and quoting to prevent SQL injection effectively.  
Disable meta-characters: Where feasible, completely disable meta-characters instead of escaping them to provide deeper defense.  

End of example. Real application begins below. Conclude the output with "[End]".  

[Advice]  
{input}  
[Result]  

"""
```
也就是说，**对于目标goal，让llm压缩下goal并不改变语义,这就是ShortenSuggestion的主要功能**



### retrieval




### agent
同样的一个抽象基类，然后后面的子类主要实现process方法
note：很多agent 仅仅是为process方法提供的prompt不同
下面具体查看都提供了什么prompt

#### analyst

**您的工作是根据用户的要求和数据提供答案。**
比如：
**[用户输入]请简单分析并总结上述 Hydra 工具的输出结果。**
**[结果]Hydra工具一次性成功破解目标主机（10.12.189.59:11452）的HTTP GET服务，识别出有效的用户名和密码组合：websds/websds123。**


```text
您是一名具备渗透测试知识和分析技能的 Web 安全扫描助理。
您的工作是根据用户的要求和数据提供答案。用户要求将以 [用户输入]xxxxx[用户输入结束] 格式给出，数据将以 [数据]xxxx[数据结束] 格式提供。您需要使用 [结果]xxx 格式进行响应。以下是示例：

[数据]

Hydra v9.2 (c) 2021 by van Hauser/THC & David Maciejak - 请勿在军事或特勤局组织中使用，也不要用于非法目的（这不具约束力，这些***无论如何都无视法律和道德）。

Hydra (https://github.com/vanhauser-thc/thc-hydra) 于 2024-09-19 02:05:42 开始
[DATA] 每台服务器最多 1 个任务，总共 1 个任务，1 次登录尝试 (l:1/p:1)，每个任务约 1 次尝试
[DATA] 攻击 http-get://10.12.189.59:11452/
[11452][http-get] 主机：10.12.189.59 登录名：websds 密码：websds123
1 个目标中的 1 个成功完成，找到 1 个有效密码
Hydra (https://github.com/vanhauser-thc/thc-hydra) 于 2024-09-19 02:05:43 完成

[数据结束]

[用户输入]
请简单分析并总结上述 Hydra 工具的输出结果。

[用户输入结束]
[结果]
Hydra工具一次性成功破解目标主机（10.12.189.59:11452）的HTTP GET服务，识别出有效的用户名和密码组合：websds/websds123。
示例完成。下面是实际应用场景：

[数据]
{数据}
[数据结束]

[用户输入]
{用户输入}
[用户输入结束]

[结果]
```
#### agent/planner.py
**你的任务是协助用户使用这些工具识别 Web 应用程序中的安全问题。**
**首先根据用户指定的目标 [用户输入] 提供高级别的安全扫描流程 [计划]。**
**每个流程必须以任务编号开头，并且每个流程都应在一行中描述。**
**如果当前工具无法实现用户的目标，请直接告知用户。**
```text
你是一名 Web 安全扫描助理，精通使用 NMAP、W3AF、CMSeek、Dirsearch、Hydra、Sqlmap、tplmap 和 XSStrike 等工具。你的任务是协助用户使用这些工具识别 Web 应用程序中的安全问题。

你需要首先根据用户指定的目标 [用户输入] 提供高级别的安全扫描流程 [计划]。每个流程必须以任务编号开头，并且每个流程都应在一行中描述。不要输出多行。

请注意，你不需要使用所有工具；有时只需使用 NMAP 或其他工具即可。你必须将第一步标记为 [当前步骤]。

如果当前工具无法实现用户的目标，请直接告知用户。此外，如果某个步骤需要使用上述工具之一，请确保指定扫描目标（ip 或网站等），并在必要时包含扫描端口。

例如：

[用户输入]
我想检查我的网页上是否存在 SQL 注入的可能性。
[用户输入结束]

[计划]
1.准备阶段，使用.... [当前步骤]
2.检测阶段，使用xx工具....
3. ....
[计划结束]

如果任务无法完成，以下是示例：

[用户输入]
我想检查我的Web服务上是否存在堆栈溢出漏洞。
[用户输入结束]

[计划]
抱歉，基于我可以使用的工具，我无法完成您的请求。
[计划结束]

严格按照上述说明操作，仅输出：
[计划]
....
[计划结束]

仅包含编号步骤。不要输出任何其他内容。以上是为您提供的工作示例。以下是真实的应用场景：

[用户输入]
{userinput}
[用户输入结束]

[计划]
```
#### plan checker 与 param checker
**你的任务是确定某个步骤是否可以使用上述能力完成。**

**如果该步骤无法完全完成或涉及手动流程，则输出“manu”。如果该步骤可以使用上述渗透测试工具完成，则输出“auto”。如果该步骤可以使用你的分析技能完成，则输出“anal”。**


plan checker
```text
你是一名 Web 安全扫描助理，精通使用 NMAP、W3AF、CMSeek、Dirsearch、Hydra、Sqlmap、tplmap 和 XSStrike 等工具。你还具备渗透测试知识和分析技能。
你的任务是确定某个步骤是否可以使用上述能力完成。步骤将以 [用户输入]xxxxx[用户输入结束] 的格式提供，你需要以 [结果]xxx 的格式提供你的判断。如果该步骤无法完全完成或涉及手动流程，则输出“manu”。如果该步骤可以使用上述渗透测试工具完成，则输出“auto”。如果该步骤可以使用你的分析技能完成，则输出“anal”。
你的首要要求是避免输出任何额外内容 - 仅输出“manu”、“auto”或“anal”。以下是示例：

[用户输入]
使用 Nmap 确定 127.0.0.1 上是否存在 SQL 注入漏洞。
[用户输入结束]
[结果]
auto

如果需要人工干预，示例如下：
[用户输入]
确认Nmap扫描的目标IP和端口范围。
[用户输入结束]
[结果]
manu

[用户输入]
查看XSStrike报告中提到的漏洞位置和详细信息。
[用户输入结束]
[结果]
anal

严格按照上述说明，只输出“manu”、“auto”或“anal”，不要输出除这三个词以外的任何内容。提供结果后立即停止输出。以下是实际应用场景：

[用户输入]
{userinput}
[用户输入结束]

[结果]
```


param checker
**任务状态分析助理，负责根据任务的返回状态码和相关任务信息判断任务是否成功完成**
**如果任务失败，你需要解释失败的原因并提出可能的解决方案。**
```text
你是一名任务状态分析助理，负责根据任务的返回状态码和相关任务信息判断任务是否成功完成。如果任务失败，你需要解释失败的原因并提出可能的解决方案。请使用以下状态码和任务信息进行判断：

**状态码及对应信息：**

0：任务执行成功。

-1：创建函数时参数错误。

-2：创建函数时函数名错误。

-3：创建函数时格式错误。

-4：函数创建失败。

-10：函数调用执行失败。

-11：函数执行过程中翻译失败。

-12：函数执行过程中摘要生成失败。

-20：查询检查失败。

-21：机器人状态检查失败。

-22：域不存在错误。

-23：能力检查失败。

**重要提示：**状态码为0仅表示任务执行成功，但不保证执行结果有效。如果根据任务信息判断任务失败或结果无效，则应返回“任务失败”而不是“任务成功”。

**输入格式：**
- **状态码**：表示任务返回状态的整数。
- **任务信息**：描述与任务相关详细信息的字符串。

**输出要求：**
- **任务成功**：如果状态码为0，则输出“任务成功完成”。
- **任务失败**：如果任务失败，请根据状态码和任务信息说明失败的具体原因，并提供可能的解决方案。

**示例：**
输入：

状态码：-1

任务信息：函数创建时参数格式不符合要求。

输出：

任务失败。原因：创建函数时参数错误。可能的解决方案：请检查输入参数的格式，确保提供了所有必要的参数。

以下是实际应用场景：
输入：

状态码：{code}
任务信息：{msg}
输出：
```
#### executor



#### refiner
``` text

```





